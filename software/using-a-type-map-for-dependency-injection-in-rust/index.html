<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Nick Bryan | Dependency Injection in Rust with Type-Maps</title>
<link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Bungee&family=Raleway&display=swap" rel=stylesheet><link href="/css/main.min.7460d488eb619a882c8ddc28e868abbe6c528494c0e40a1f28269214be6962c6.css" rel=stylesheet></head><body class="font-text text-white"><header><div class="bg-midnight sticky top-0 z-50"><nav class="flex items-center p-6 container mx-auto"><a href=https://nickbryan.co.uk/><span class="h-10 w-10 text-5xl font-logo tracking-tighter mr-2.5 text-green-400 hover:text-white">NB</span>
</a><span class="pl-5 sm:pl-10"><a href=https://nickbryan.co.uk/><span class="font-title
tracking-tighter
text-green-400
hover:text-white
text-ms
sm:text-3xl">Home
</span></a></span><span class="pl-3 sm:pl-10"><a href=/software/><span class="font-title
tracking-tighter
underline
text-white
hover:text-green-400
text-ms
sm:text-3xl">Software</span></a></span></nav></div><div class=bg-midnight-light><div class="bg-gradient-to-r from-purple-700 to-pink-600 -skew-y-11 p-6 sm:p-10"><div class="flex flex-col lg:flex-row items-center p-3 sm:p-9 container mx-auto text-black skew-y-11 justify-center"><section><div class="max-w-prose bg-midnight text-gray-300 p-4 rounded-tr rounded-b shadow"><div class="font-title text-green-400 text-center p-5 text-3xl"><h1>Dependency Injection in Rust with Type-Maps</h1></div><div class="mb-2 text-gray-400 text-center"><span class="inline-block w-3 h-3 relative -top-0.5"><svg viewBox="0 0 448 512"><path fill="currentcolor" d="M0 464c0 26.5 21.5 48 48 48h352c26.5.0 48-21.5 48-48V192H0v272zm320-196c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v40c0 6.6-5.4 12-12 12h-40c-6.6.0-12-5.4-12-12v-40zm0 128c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v40c0 6.6-5.4 12-12 12h-40c-6.6.0-12-5.4-12-12v-40zM192 268c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v40c0 6.6-5.4 12-12 12h-40c-6.6.0-12-5.4-12-12v-40zm0 128c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v40c0 6.6-5.4 12-12 12h-40c-6.6.0-12-5.4-12-12v-40zM64 268c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v40c0 6.6-5.4 12-12 12H76c-6.6.0-12-5.4-12-12v-40zm0 128c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v40c0 6.6-5.4 12-12 12H76c-6.6.0-12-5.4-12-12v-40zM4e2 64h-48V16c0-8.8-7.2-16-16-16h-32c-8.8.0-16 7.2-16 16v48H160V16c0-8.8-7.2-16-16-16h-32c-8.8.0-16 7.2-16 16v48H48C21.5 64 0 85.5.0 112v48h448v-48c0-26.5-21.5-48-48-48z"/></svg>
</span><span class=mr-3>26 Feb 22
</span><span>10 min read</span></div><p>In this article we will look at type-maps and how they can help enable dependency injection in Rust. We will go a few steps further to look at how we can provide auto wiring of arguments to a given callable, utilising generics and a few traits. This is a pattern seen in frameworks such as Bevy and Actix-Web to provide shared state back to the user.</p></div></section></div></div></div></header><div class="bg-midnight min-h-screen relative z-40"><main class="flex flex-col p-5 sm:p-10 md:p-20 container mx-auto"><section class="max-w-full mx-auto"><article class="prose
max-w-5xl
prose-sm
md:prose-lg
lg:prose-xl
prose-invert
prose-code:before:content-none
prose-code:after:content-none
prose-a:text-green-400
hover:prose-a:text-white"><h1 id=type-maps>Type Maps</h1><p>It is common in dynamically typed languages, such as PHP, to use a service container
to aid in dependency injection. Dependency injection containers are usually represented as some sort of map/dictionary
where a string representation of the type is set as the key and an instance of the type is set as the value.
We can do something similar at compile time in Rust using a <em>type-map</em> as the core of the container.</p><aside class="container mx-auto pl-10"><div><h3 class=underline>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#a-simple-type-map>A simple type-map</a></li><li><a href=#injecting-a-single-dependency>Injecting a single dependency</a></li><li><a href=#injecting-multiple-dependencies>Injecting multiple dependencies</a></li><li><a href=#the-final-code>The final code</a></li><li><a href=#further-reading>Further reading</a></li></ul></nav></div></aside><p>A <em>type-map</em> is a container that stores some value against its given
unique type identifier in order for state to be shared within an application. They are
usually represented as a form of <code>HashMap</code> where the key is <code>std::any::TypeId</code>
and the value is <code>std::any::Any</code>. This can add a dynamic element to an
otherwise statically and strongly-typed systems language.</p><p>I first stumbled upon this pattern when looking at <code>systems</code> in the Bevy game engine. At the time, I couldn&rsquo;t
understand how the game engine knew how to wire up <code>components</code>, <code>queries</code>, etc. to the systems, solely based on the
type signatures of the function arguments. I then came across it again in the Actix Web framework where it is used to
pass shared application state, like a database connection, to multiple handlers. It was after researching the
intricacies of this pattern that I decided it would be best to keep some notes for myself, and thus I ended up with this article.</p><p>Let&rsquo;s have a look at how we can create a basic dependency injection container in Rust that can auto wire function arguments.</p><h2 id=a-simple-type-map>A simple type-map</h2><p>Let&rsquo;s start by building a simple type-map to demonstrate what they are. A test
is always a good place to start:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[cfg(test)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> tests {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> <span style=color:#66d9ef>super</span>::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>a_type_can_be_bound_and_resolved</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> container <span style=color:#f92672>=</span> TypeMap::default();
</span></span><span style=display:flex><span>        container.bind::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>42</span>);
</span></span><span style=display:flex><span>        assert_eq!(container.get::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span>(), Some(<span style=color:#f92672>&amp;</span><span style=color:#ae81ff>42</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>This should be fairly self-explanatory. First, we create a <code>container</code> and <code>bind</code> the
value <code>42</code> to the type <code>i32</code>. Then, we assert that the value matching the given type
resolves to the correct value. As is common practice in Rust, our <code>get</code> method returns
a reference to the contained value. We will have a look at other ways to resolve our
values towards the end of the article.</p><p>You may be wondering what the strange looking <code>method_name::&lt;T>()</code> syntax is all
about. This is commonly known as the <em>turbofish</em> operator and is Rust&rsquo;s way of
specifying the type for a generic parameter. Rust is smart enough to
<a href=https://doc.rust-lang.org/rust-by-example/types/inference.html>infer</a> the types we are
asking for, so we can actually remove the turbofish operators here.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>a_type_can_be_bound_and_resolved_through_inference</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> container <span style=color:#f92672>=</span> TypeMap::default();
</span></span><span style=display:flex><span>    container.bind(<span style=color:#ae81ff>42</span>);
</span></span><span style=display:flex><span>    assert_eq!(container.get(), Some(<span style=color:#f92672>&amp;</span><span style=color:#ae81ff>42</span>));
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Let&rsquo;s have a look at the implementation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::{
</span></span><span style=display:flex><span>    any::{Any, TypeId},
</span></span><span style=display:flex><span>    collections::HashMap,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Default)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>TypeMap</span> {
</span></span><span style=display:flex><span>    bindings: <span style=color:#a6e22e>HashMap</span><span style=color:#f92672>&lt;</span>TypeId, Box<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>dyn</span> Any<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> TypeMap {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>bind</span><span style=color:#f92672>&lt;</span>T: <span style=color:#a6e22e>Any</span><span style=color:#f92672>&gt;</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, val: <span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>        self.bindings.insert(val.type_id(), Box::new(val));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get</span><span style=color:#f92672>&lt;</span>T: <span style=color:#a6e22e>Any</span><span style=color:#f92672>&gt;</span>(<span style=color:#f92672>&amp;</span>self) -&gt; Option<span style=color:#f92672>&lt;&amp;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        self.bindings
</span></span><span style=display:flex><span>            .get(<span style=color:#f92672>&amp;</span>TypeId::of::<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>())
</span></span><span style=display:flex><span>            .and_then(<span style=color:#f92672>|</span>boxed<span style=color:#f92672>|</span> boxed.downcast_ref())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Things are starting to get interesting, but this is still a relatively
straightforward implementation. We represent the contained bindings with a
<code>HashMap&lt;TypeId, Box&lt;dyn Any>></code>. The value is boxed in order for the size of
the type implementing <code>dyn Any</code> to be known at compile time.</p><p><code>TypeId::of::&lt;T>()</code> returns the <code>TypeId</code> of the type the generic function has been instantiated with. We use it in <code>get</code>
to represent the type when accessing the <code>HashMap</code> and implicitly through <code>val.type_id()</code> in <code>bind</code>.
This is possible due to <code>T</code> implementing the <code>std::any::Any</code> trait. Finally, the value must be unboxed
and downcast to a reference to allow shared access.</p><p>If we run our tests we should now see everything passing:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>┌nick@Nicks-MBP ~/c/typemap <span style=color:#f92672>(</span>master +%<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>└&gt; cargo test
</span></span><span style=display:flex><span>Finished test <span style=color:#f92672>[</span>unoptimized + debuginfo<span style=color:#f92672>]</span> target<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> in 0.01s
</span></span><span style=display:flex><span>Running unittests <span style=color:#f92672>(</span>target/debug/deps/typemap-2c921a98b228541f<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>running <span style=color:#ae81ff>2</span> tests
</span></span><span style=display:flex><span>test tests::a_type_can_be_bound_and_resolved ... ok
</span></span><span style=display:flex><span>test tests::a_type_can_be_bound_and_resolved_through_inference ... ok
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test result: ok. <span style=color:#ae81ff>2</span> passed; <span style=color:#ae81ff>0</span> failed; <span style=color:#ae81ff>0</span> ignored; <span style=color:#ae81ff>0</span> measured; <span style=color:#ae81ff>0</span> filtered out; finished in 0.00s
</span></span><span style=display:flex><span>...</span></span></code></pre></div><h2 id=injecting-a-single-dependency>Injecting a single dependency</h2><p>Some service containers that handle automatic injection of dependencies (auto-wiring) will provide a method that the user
can pass a callable to in order for its dependencies to be injected via the container. Let&rsquo;s see how that might work
in Rust. We can define another test to demonstrate what we are trying to achieve:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>injects_dependency_based_on_argument_type</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> container <span style=color:#f92672>=</span> TypeMap::default();
</span></span><span style=display:flex><span>    container.bind(Data::new(<span style=color:#ae81ff>42</span>));
</span></span><span style=display:flex><span>    container.call(<span style=color:#f92672>|</span>data: <span style=color:#a6e22e>Data</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;|</span> {
</span></span><span style=display:flex><span>        assert_eq!(data.get_ref(), <span style=color:#f92672>&amp;</span><span style=color:#ae81ff>42</span>);
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>As you can see, there is something that looks pretty &ldquo;magic&rdquo; going on here. How does the <code>call</code> method know to pass
our <code>Data&lt;i32></code> into the closure? You may also be wondering why we now need a <code>Data&lt;T></code> at all – hopefully that will
become clear as we demystify this.</p><p>Let&rsquo;s start by looking at the implementation of our <code>call</code> method so that we can get some context.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>call</span><span style=color:#f92672>&lt;</span>F, Args<span style=color:#f92672>&gt;</span>(<span style=color:#f92672>&amp;</span>self, callable: <span style=color:#a6e22e>F</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    F: <span style=color:#a6e22e>Callable</span><span style=color:#f92672>&lt;</span>Args<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    Args: <span style=color:#a6e22e>FromTypeMap</span>,
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    callable.call(Args::from_type_map(self));
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>So, we take in some function <code>F</code> that implements a <code>Callable</code> trait which allows us to <code>call</code> the function with some
arguments <code>Args</code>. Our arguments <code>Args</code> implement a <code>FromTypeMap</code> trait that allows us to build up the arguments from
our type-map. These traits are pretty straight forward too. Let&rsquo;s take a look:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>trait</span> Callable<span style=color:#f92672>&lt;</span>Args<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>call</span>(<span style=color:#f92672>&amp;</span>self, args: <span style=color:#a6e22e>Args</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>trait</span> FromTypeMap {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from_type_map</span>(type_map: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>TypeMap</span>) -&gt; <span style=color:#a6e22e>Self</span>;
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Okay&mldr; so how do these traits allow automatic injection of our argument based on a given type? Hopefully the implementation
of <code>FromTypeMap</code> will clear this up. Let&rsquo;s see how we can implement that for an <code>i32</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> FromTypeMap <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from_type_map</span>(type_map: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>TypeMap</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        type_map.get::<span style=color:#f92672>&lt;</span>Self<span style=color:#f92672>&gt;</span>().expect(<span style=color:#e6db74>&#34;type not found&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>We use the <code>get</code> method on the type-map to resolve our type. We then clone the value so that we can return an owned
version to the caller. This works fine for an <code>i32</code> as it implements <code>Copy</code>, but what if we wanted to allow for
any type? This is where our <code>Data&lt;T></code> comes in. Let&rsquo;s have a look at the definition of this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Data</span><span style=color:#f92672>&lt;</span>T: <span style=color:#f92672>?</span>Sized<span style=color:#f92672>&gt;</span>(Arc<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Data<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(val: <span style=color:#a6e22e>T</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Data(Arc::new(val))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T: <span style=color:#f92672>?</span>Sized<span style=color:#f92672>&gt;</span> Data<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>T</span> {
</span></span><span style=display:flex><span>        self.<span style=color:#ae81ff>0.</span>as_ref()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T: <span style=color:#f92672>?</span>Sized<span style=color:#f92672>&gt;</span> Clone <span style=color:#66d9ef>for</span> Data<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>clone</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#a6e22e>Data</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        Data(self.<span style=color:#ae81ff>0.</span>clone())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T: <span style=color:#f92672>?</span>Sized<span style=color:#f92672>&gt;</span> Deref <span style=color:#66d9ef>for</span> Data<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Target</span> <span style=color:#f92672>=</span> Arc<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>deref</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Arc</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span>self.<span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T: <span style=color:#f92672>?</span>Sized <span style=color:#f92672>+</span> &#39;static<span style=color:#f92672>&gt;</span> FromTypeMap <span style=color:#66d9ef>for</span> Data<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from_type_map</span>(type_map: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>TypeMap</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        type_map.get::<span style=color:#f92672>&lt;</span>Self<span style=color:#f92672>&gt;</span>().expect(<span style=color:#e6db74>&#34;type not found&#34;</span>).clone()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>If we start by looking at the implementation of the <code>FromTypeMap</code> trait for our <code>Data&lt;T></code> we can see that the method
body is the same as our <code>i32</code> version. The interesting stuff comes from the defined methods and the implementation of the
<code>Clone</code> trait that, together, make this possible. We wrap the <code>T</code> in an <code>Arc</code> which provides us with two benefits – the
first being that it gives us thread safety and the second being that it allows us to clone our value easily and safely.
<code>Clone</code> is required so that we can actually clone the <code>Data&lt;T></code> which we do by just cloning the inner <code>Arc&lt;T></code> and returning a
new <code>Data</code> with the cloned value inside. Implementing <code>Deref</code> gives us some syntactic sugar so that we can access the inner
value&rsquo;s methods via the dot notation (Arc also implements <code>Defef</code>). Let&rsquo;s write a test to show this in action and to also
prove that we can pass any type:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>the_values_methods_can_be_accessed_through_deref</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> container <span style=color:#f92672>=</span> TypeMap::default();
</span></span><span style=display:flex><span>    container.bind(Data::new(String::from(<span style=color:#e6db74>&#34;test test 123&#34;</span>)));
</span></span><span style=display:flex><span>    container.call(<span style=color:#f92672>|</span>data: <span style=color:#a6e22e>Data</span><span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;|</span> {
</span></span><span style=display:flex><span>        assert_eq!(data.as_str(), <span style=color:#e6db74>&#34;test test 123&#34;</span>);
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>With this in place, our <code>Data&lt;T></code> container will allow us to have
any optionally <code>Sized</code> type injected into our function if we wrap it in our <code>Data&lt;T></code> container, which is pretty nice.</p><p>Now for the last piece of the puzzle. How do we get our <code>Data&lt;T></code> into our closure? Well, that&rsquo;s what the <code>Callable</code> trait
is for:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>Func, Arg1<span style=color:#f92672>&gt;</span> Callable<span style=color:#f92672>&lt;</span>Arg1<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Func
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    Func: Fn(Arg1),
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>call</span>(<span style=color:#f92672>&amp;</span>self, arg1: <span style=color:#a6e22e>Arg1</span>) {
</span></span><span style=display:flex><span>        (self)(arg1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Here, we are implementing the <code>Callable</code> trait for a closure that takes one argument (for now) and returns nothing. In
the body of our <code>call</code> method, we just call the closure with the given argument. This is where our limitation of injecting
a single dependency comes into play as we have to be explicit about the number of arguments we are passing in.</p><h2 id=injecting-multiple-dependencies>Injecting multiple dependencies</h2><p>In order to allow for multiple arguments being passed into our <code>Callable</code>s, we need to define a single type that
we can implement <code>FromTypeMap</code> on in order to inject our <code>Args</code> into the <code>call</code> method as a single value. We can do this with a
tuple, with the only downside being that we will still have to be explicit about the number of arguments we are allowing in the <code>Callable</code>.</p><p>Let&rsquo;s update our code to use a tuple for the <code>Callable</code> with a single argument:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>Func, A<span style=color:#f92672>&gt;</span> Callable<span style=color:#f92672>&lt;</span>(A,)<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Func
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    Func: Fn(A),
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>call</span>(<span style=color:#f92672>&amp;</span>self, (a,): (A,)) {
</span></span><span style=display:flex><span>        (self)(a)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Next, we will need to implement the <code>FromTypeMap</code> trait for a single value tuple so that we can build up its members
automatically from the type-map:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>A: <span style=color:#a6e22e>FromTypeMap</span><span style=color:#f92672>&gt;</span> FromTypeMap <span style=color:#66d9ef>for</span> (A,) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from_type_map</span>(type_map: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>TypeMap</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        (A::from_type_map(type_map),)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Here, we are saying that we want to implement the <code>FromTypeMap</code> trait for a tuple that has a <code>T</code> which also implements the
<code>FromTypeMap</code> trait. This allows us to then call <code>T::from_type_map(type_map)</code> to build the argument for the tuple that we
are building from the container.</p><p>This may be more clear when we look at how we would do that for a two-argument tuple and its <code>Callable</code> implementation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>Func, A, B<span style=color:#f92672>&gt;</span> Callable<span style=color:#f92672>&lt;</span>(A, B)<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Func
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    Func: Fn(A, B),
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>call</span>(<span style=color:#f92672>&amp;</span>self, (a, b): (A, B)) {
</span></span><span style=display:flex><span>        (self)(a, b)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>A: <span style=color:#a6e22e>FromTypeMap</span>, B: <span style=color:#a6e22e>FromTypeMap</span><span style=color:#f92672>&gt;</span> FromTypeMap <span style=color:#66d9ef>for</span> (A, B) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from_type_map</span>(type_map: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>TypeMap</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        (A::from_type_map(type_map), B::from_type_map(type_map))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>We could then carry on implementing this for as many arguments as we want to allow in the API of our type-map. However, this
is a lot of repeated code that is more difficult to maintain. A common approach to solving this is to allow up to a
reasonably-sized fixed number of arguments to be passed to our callable for dependency resolution, and to generate
this using a macro:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>macro_rules<span style=color:#f92672>!</span> callable_tuple ({ <span style=color:#75715e>$($param</span>:<span style=color:#a6e22e>ident</span>)<span style=color:#f92672>*</span> } <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>Func, <span style=color:#75715e>$($param</span>,)<span style=color:#f92672>*&gt;</span> Callable<span style=color:#f92672>&lt;</span>(<span style=color:#75715e>$($param</span>,)<span style=color:#f92672>*</span>)<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Func
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>        Func: Fn(<span style=color:#75715e>$($param</span>),<span style=color:#f92672>*</span>),
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>#[inline]</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>#[allow(non_snake_case)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>call</span>(<span style=color:#f92672>&amp;</span>self, (<span style=color:#75715e>$($param</span>,)<span style=color:#f92672>*</span>): (<span style=color:#75715e>$($param</span>,)<span style=color:#f92672>*</span>)) {
</span></span><span style=display:flex><span>            (self)(<span style=color:#75715e>$($param</span>,)<span style=color:#f92672>*</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>callable_tuple! {}
</span></span><span style=display:flex><span>callable_tuple! { A }
</span></span><span style=display:flex><span>callable_tuple! { A B }
</span></span><span style=display:flex><span>callable_tuple! { A B C }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>macro_rules<span style=color:#f92672>!</span> tuple_from_tm {
</span></span><span style=display:flex><span>        ( <span style=color:#75715e>$($T</span>: <span style=color:#a6e22e>ident</span> )<span style=color:#f92672>+</span> ) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span><span style=color:#75715e>$($T</span>: <span style=color:#a6e22e>FromTypeMap</span>),<span style=color:#f92672>+&gt;</span> FromTypeMap <span style=color:#66d9ef>for</span> (<span style=color:#75715e>$($T</span>,)<span style=color:#f92672>+</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#75715e>#[inline]</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from_type_map</span>(type_map: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>TypeMap</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>                    (<span style=color:#75715e>$($T</span>::from_type_map(type_map),)<span style=color:#f92672>+</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>tuple_from_tm! { A }
</span></span><span style=display:flex><span>tuple_from_tm! { A B }
</span></span><span style=display:flex><span>tuple_from_tm! { A B C }</span></span></code></pre></div><p>The details on how macros work is out of the scope of this article, but the above is essentially saying:</p><blockquote><p>Generate the code to implement the <code>Callable</code> and <code>FromTypeMap</code> trait for tuples with the argument length of the given number of arguments
in the macro.</p></blockquote><p>The letters in the macro call represent the name of the type of each individual argument in the tuple. We can then specify
up to a set number of arguments allowed in our API. In most cases this is done for up to twelve arguments as seen in the
final code below.</p><h2 id=the-final-code>The final code</h2><p>Here is a link to the <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=5437df63d8734a4f14856f153ef700a6">final code</a>
where you can find everything we have implemented above, as well as some comments and additional tests to help explain what&rsquo;s
going on.</p><h2 id=further-reading>Further reading</h2><ul><li><a href=https://github.com/bevyengine/bevy>Bevy</a> - The <code>bevy_reflect</code> crate uses a much more advanced version of this pattern
to build up the arguments for systems.</li><li><a href=https://github.com/actix/actix-web>Actix Web</a> - I took a lot of information from Actix Web as it uses this pattern to build the extractors for requests.</li></ul></article></section></main></div><div class=bg-midnight-dark><footer class="flex flex-col items-center justify-center p-6 container mx-auto"><p>Copyright &#169; 2024 Nicholas Bryan</p><p class=text-gray-400>Powered by <a href=https://gohugo.io/ class="underline hover:text-white">Hugo</a></p><p class=text-gray-400>Custom theme built with <a href=https://tailwindcss.com/ class="underline hover:text-white">Tailwind</a></p><button id=scrollToTopBtn class="bg-green-400 rounded-md border-none p-3 cursor-pointer w-19 fixed bottom-12 right-12 z-50 translate-y-96 transition-all ease-in delay-500 opacity-0">
<span class="text-midnight font-bold font-title">&uarr; Top</span>️</button></footer></div><script type=application/javascript>const scrollToTopBtn=document.getElementById("scrollToTopBtn"),rootElement=document.documentElement;scrollToTopBtn.addEventListener("click",()=>{rootElement.scrollTo({top:0,behavior:"smooth"})}),document.addEventListener("scroll",()=>{let e=rootElement.scrollHeight-rootElement.clientHeight;if(rootElement.scrollTop/e>.25){scrollToTopBtn.classList.remove("translate-y-96","opacity-0"),scrollToTopBtn.classList.add("opacity-1","translate-y-0");return}scrollToTopBtn.classList.remove("translate-y-0","opacity-1"),scrollToTopBtn.classList.add("translate-y-96","opacity-0")})</script></body></html>